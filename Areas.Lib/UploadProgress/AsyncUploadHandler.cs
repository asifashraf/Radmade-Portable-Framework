// Generated by Reflector from D:\eConsular\src\Areas\Lib\RadWebUI\Areas.Lib.UploadProgress.dll

namespace Areas.Lib.UploadProgress
{
    using System;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Web;
    using System.Web.Caching;
    using System.Web.SessionState;
    using Areas.Lib.UploadProgress.AsyncUpload;

    [RadCompressionSettings(HttpCompression = CompressionType.None)]
    public class AsyncUploadHandler : IHttpHandler, IRequiresSessionState
    {
        internal const string Max_File_Size_Exceeded = "{ \"invalidFileSize\" : true }";
        internal const string Meta_Data_String = "metadata";
        internal const string Post_Data_Key = "rauPostData";
        internal const string Return_Next_Chunk = "next";
        private string temporaryFileName;

        public AsyncUploadHandler()
        {
        }

        public AsyncUploadHandler(IRequestData requestData, IResponseWriter responseWriter, ITempFileAppender fileAppender)
        {
            this.RequestData = requestData;
            this.ResponseWriter = responseWriter;
            this.FileAppender = fileAppender;
        }

        internal virtual void AddCacheDependency(HttpContext context, string tempFileName, TimeSpan timeToLive, string fullPath)
        {
            if (context.Cache.Get(tempFileName) == null)
            {
                context.Cache.Insert(tempFileName, fullPath, null, DateTime.Now.Add(timeToLive), TimeSpan.Zero, CacheItemPriority.NotRemovable, new CacheItemRemovedCallback(this.RemovedCallback));
            }
        }

        protected T CreateDefaultUploadResult<T>(UploadedFile file) where T : IAsyncUploadResult, new()
        {
            T result = (default(T) == null) ? Activator.CreateInstance<T>() : default(T);
            UploadedFileInfo.CopyFileInfo(result, file);
            return result;
        }

        protected static string DecryptFolder(string rawData)
        {
            return CryptoService.Decrypt(rawData);
        }

        internal void EnsureSetup()
        {
            if (this.RequestData == null)
            {
                this.RequestData = new Areas.Lib.UploadProgress.AsyncUpload.RequestData(this.Context);
            }
            if (this.ResponseWriter == null)
            {
                this.ResponseWriter = new Areas.Lib.UploadProgress.AsyncUpload.ResponseWriter(this.Context);
            }
            if ((this.FileAppender == null) && this.ChunkUploadRequest)
            {
                this.FileAppender = new ContentAppender(this.RequestData.UploadedFile.InputStream);
            }
            if (this.Configuration == null)
            {
                this.Configuration = this.GetConfiguration(this.Context.Request["rauPostData"]);
            }
        }

        internal IAsyncUploadConfiguration GetConfiguration(string rawData)
        {
            string[] strArray = rawData.Split(new char[] { '&' });
            string str = strArray[0];
            Type type = Type.GetType(CryptoService.Decrypt(strArray[1]));
            IAsyncUploadConfiguration configuration = (IAsyncUploadConfiguration)SerializationService.Deserialize(str, type, true);
            configuration.TargetFolder = DecryptFolder(configuration.TargetFolder);
            configuration.TempTargetFolder = DecryptFolder(configuration.TempTargetFolder);
            return configuration;
        }

        internal void HandleChunkUploadRequest(string serializedMetaData)
        {
            ChunkMetaData data = (ChunkMetaData)SerializationService.Deserialize(serializedMetaData, typeof(ChunkMetaData));
            if (data.IsSingleChunkUpload)
            {
                this.RequestData.UploadedFile = new AsyncPostedFile(this.RequestData.UploadedFile, this.FullPath, this.RequestData.UploadedFile.ContentLength, false);
                (this.RequestData.UploadedFile as AsyncPostedFile).NormalizeWith(this.RequestData.FormValues);
                this.ProcessUploadedFile();
            }
            else if (this.ValidateSize(data.TotalFileSize, this.Configuration.MaxFileSize))
            {
                if (!this.IsFileSizeValid(Convert.ToInt32(data.TotalFileSize), this.Configuration.MaxFileSize))
                {
                    this.ResponseWriter.WriteToResponse("{ \"invalidFileSize\" : true }");
                }
                else
                {
                    bool flag = data.ChunkIndex == --data.TotalChunks;
                    bool flag2 = data.ChunkIndex == 0;
                    this.TemporaryFileName = data.UploadID;
                    this.FileAppender.AppendTo(this.FullPath);
                    if (flag)
                    {
                        this.RequestData.UploadedFile = new AsyncPostedFile(this.RequestData.UploadedFile, this.FullPath, this.FileAppender.AppendedContentLength, true);
                        (this.RequestData.UploadedFile as AsyncPostedFile).NormalizeWith(this.RequestData.FormValues);
                        this.ProcessUploadedFile();
                    }
                    else
                    {
                        if (flag2)
                        {
                            this.AddCacheDependency(this.Context, data.UploadID, this.Configuration.TimeToLive, this.FullPath);
                        }
                        this.ResponseWriter.WriteToResponse("next");
                    }
                }
            }
        }

        protected bool IsFileSizeValid(int contentLength, int maxFileSize)
        {
            if ((maxFileSize > 0) && (contentLength > maxFileSize))
            {
                return false;
            }
            return true;
        }

        protected internal virtual IAsyncUploadResult Process(UploadedFile file, HttpContext context, IAsyncUploadConfiguration configuration, string tempFileName)
        {
            this.SaveToTempFolder(file, configuration, context, tempFileName);
            return this.CreateDefaultUploadResult<UploadedFileInfo>(file);
        }

        public void ProcessRequest(HttpContext context)
        {
            if (context.Request.Files.Count == 0)
            {
                this.ResponseWriter.WriteToResponse("{ \"message\" : \"RadAsyncUpload handler is registered succesfully, however, it may not be accessed directly.\" }");
            }
            else
            {
                this.Context = context;
                this.EnsureSetup();
                if (!this.ChunkUploadRequest)
                {
                    this.RequestData.UploadedFile = new AsyncPostedFile(this.RequestData.UploadedFile, this.FullPath, this.RequestData.UploadedFile.ContentLength);
                    this.ProcessUploadedFile();
                }
                else
                {
                    this.HandleChunkUploadRequest(context.Request.Form["metadata"]);
                }
            }
        }

        private void ProcessUploadedFile()
        {
            if (this.ValidateSize(this.RequestData.UploadedFile.ContentLength, this.Configuration.MaxFileSize))
            {
                IAsyncUploadResult fileInfo = this.Process(this.RequestData.UploadedFile, this.Context, this.Configuration, this.TemporaryFileName);
                MetaData metaData = new MetaData
                {
                    TempFileName = this.TemporaryFileName,
                    AsyncUploadTypeName = fileInfo.GetType().AssemblyQualifiedName
                };
                this.ResponseWriter.WriteToResponse(this.SerializeClientObject(fileInfo, metaData));
            }
        }

        private void RemovedCallback(string key, object value, CacheItemRemovedReason reason)
        {
            string path = (string)value;
            if (File.Exists(path))
            {
                File.Delete(path);
            }
        }

        protected void SaveToTempFolder(UploadedFile file, IAsyncUploadConfiguration config, HttpContext context, string tempFileName)
        {
            this.AddCacheDependency(context, tempFileName, config.TimeToLive, this.FullPath);
            file.SaveAs(this.FullPath, false);
        }

        private string SerializeClientObject(IAsyncUploadResult fileInfo, MetaData metaData)
        {
            string str = SerializationService.Serialize(fileInfo);
            string str2 = SerializationService.Serialize(metaData, true);
            fileInfo.FileName = Path.GetFileName(fileInfo.FileName);
            return string.Format("{{\"fileInfo\":{0}, \"metaData\":\"{1}\" }}", str, str2);
        }

        private bool ValidateSize(int fileSize, int maxFileSize)
        {
            if (this.IsFileSizeValid(fileSize, maxFileSize))
            {
                return true;
            }
            this.ResponseWriter.WriteToResponse("{ \"invalidFileSize\" : true }");
            return false;
        }

        internal bool ChunkUploadRequest
        {
            get
            {
                return ((this.RequestData.FormValues != null) && (this.RequestData.FormValues["metadata"] != null));
            }
        }

        public IAsyncUploadConfiguration Configuration { get; set; }

        internal HttpContext Context { get; set; }

        internal ITempFileAppender FileAppender { get; set; }

        public string FullPath
        {
            get
            {
                return Path.Combine(this.TemporaryFolder, this.TemporaryFileName);
            }
        }

        public bool IsReusable
        {
            get
            {
                return true;
            }
        }

        internal IRequestData RequestData { get; set; }

        internal IResponseWriter ResponseWriter { get; set; }

        public string TemporaryFileName
        {
            get
            {
                if (string.IsNullOrEmpty(this.temporaryFileName))
                {
                    this.temporaryFileName = Path.GetRandomFileName();
                }
                return this.temporaryFileName;
            }
            set
            {
                this.temporaryFileName = value;
            }
        }

        public virtual string TemporaryFolder
        {
            get
            {
                return this.Configuration.TempTargetFolder;
            }
            set
            {
                this.Configuration.TempTargetFolder = value;
            }
        }
    }
}
